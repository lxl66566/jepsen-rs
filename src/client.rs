use std::{
    fmt,
    sync::{Arc, Mutex, OnceLock},
};

use anyhow::Result;
use log::{debug, info, trace};
use madsim::runtime::NodeHandle;

use crate::{
    checker::{elle_rw::ElleRwChecker, Check, CheckOption, SerializableCheckResult},
    generator::{Generator, GeneratorBuilder, GeneratorIter, Global, RawGenerator},
    history::HistoryType,
    nemesis::{
        implementation::{NemesisCalculator, NemesisCluster, NemesisExecutor},
        register::NemesisRegister,
        AllNemesis, NemesisType, ServerId,
    },
    op::{nemesis::OpOrNemesis, Op},
};

/// The interface of a cluster client, needs to be implemented by the external
/// user.
#[async_trait::async_trait]
pub trait ElleRwClusterClient {
    async fn get(&self, key: u64) -> std::result::Result<Option<u64>, String>;
    async fn put(&self, key: u64, value: u64) -> std::result::Result<(), String>;
    async fn txn(&self, ops: Vec<Op>) -> std::result::Result<Vec<Op>, String>;
}

/// The trait for a client that could handle nemesis operations.
///
/// If you want to use nemesis in the test, you need to implement this
/// function.
///
/// If you don't use nemesis, just make it `unimplemented!()`.
#[async_trait::async_trait]
pub trait NemesisClusterClient {
    /// The Client needs to get all `NodeHandle`s of the cluster, so that it can
    /// kill, pause and clog net of the cluster node.
    async fn get_all_nodes_handle(&self) -> Vec<NodeHandle>;
    async fn get_leader_without_term(&self) -> ServerId;
    fn size(&self) -> usize;
}

/// The interface of a jepsen client.
#[async_trait::async_trait]
pub trait Client<U: Send + fmt::Debug = OpOrNemesis> {
    type ERR: Send + 'static;
    /// client received an op, send it to cluster and deal the result. The
    /// history (both invoke and result) will be recorded in this function.
    async fn handle_op(&'static self, id: u64, op: U);
    async fn run(
        &'static self,
        gen: impl GeneratorIter<Item = U> + Send,
    ) -> Result<SerializableCheckResult, Self::ERR>;
    fn new_generator(&self, n: usize) -> Generator<'static, U, Self::ERR>;
    fn new_nemeses(
        &self,
        nemesis_seq: impl IntoIterator<Item = NemesisType> + Send,
    ) -> Generator<'static, OpOrNemesis, Self::ERR>;
}

/// A client that leads the jepsen test, execute between the generator and the
/// cluster, and record the history file.
pub struct JepsenClient<EC: ElleRwClusterClient + NemesisClusterClient + Send + Sync + 'static> {
    cluster_client: EC,
    pub global: Arc<Global<'static, OpOrNemesis, <Self as Client>::ERR>>,
    pub all_handles: OnceLock<Vec<NodeHandle>>,
    pub n_register: Mutex<NemesisRegister>,
}

impl<EC: ElleRwClusterClient + NemesisClusterClient + Send + Sync + 'static> JepsenClient<EC> {
    pub fn new(
        cluster: EC,
        raw_gen: impl RawGenerator<Item = OpOrNemesis> + Send + 'static,
    ) -> Self {
        Self {
            cluster_client: cluster,
            global: Arc::new(Global::new(raw_gen)),
            all_handles: OnceLock::new(),
            n_register: NemesisRegister::default().into(),
        }
    }

    /// Recursively handle an op, return the result.
    #[allow(clippy::await_holding_lock)]
    #[async_recursion::async_recursion]
    pub async fn handle_op_inner(&self, op: Op) -> std::result::Result<Op, String> {
        match op {
            Op::Read(key, _) => {
                let value = self.cluster_client.get(key).await?;
                Ok(Op::Read(key, value))
            }
            Op::Write(key, value) => {
                self.cluster_client.put(key, value).await?;
                Ok(Op::Write(key, value))
            }
            Op::Txn(ops) => Ok(Op::Txn(self.cluster_client.txn(ops).await?)),
        }
    }
}

#[async_trait::async_trait]
impl<EC: ElleRwClusterClient + NemesisClusterClient + Send + Sync + 'static> Client<OpOrNemesis>
    for JepsenClient<EC>
{
    type ERR = String;

    /// take n Ops from Global [`RawGenerator`].
    fn new_generator(&self, n: usize) -> Generator<'static, OpOrNemesis, Self::ERR> {
        debug!("Jepsen client make new generator with {} ops", n);
        let global = self.global.clone();
        let seq = global.take_seq(n);
        GeneratorBuilder::new(global)
            .seq(tokio_stream::iter(seq))
            .build()
    }

    /// Create a Nemesis generator from given nemeses sequence.
    fn new_nemeses(
        &self,
        nemesis_seq: impl IntoIterator<Item = NemesisType> + Send,
    ) -> Generator<'static, OpOrNemesis, Self::ERR> {
        debug!("Jepsen client make new nemesis generator");
        let global = self.global.clone();
        let seq = tokio_stream::iter(
            nemesis_seq
                .into_iter()
                .map(OpOrNemesis::from)
                .collect::<Vec<_>>(),
        );
        GeneratorBuilder::new(global).seq(seq).build()
    }

    /// Handle an [`OpOrNemesis`] which generated by a generator, and record it
    /// to history.
    async fn handle_op(&'static self, id: u64, op: OpOrNemesis) {
        trace!(
            "Jepsen client thread {} receive and handles an op: {:?}",
            id,
            op
        );
        match op {
            OpOrNemesis::Op(op) => {
                self.global
                    .history
                    .lock()
                    .unwrap()
                    .push_invoke(&self.global, id, op.clone());
                let res = self.handle_op_inner(op.clone()).await;
                match res {
                    Ok(op) => {
                        self.global.history.lock().unwrap().push_result(
                            &self.global,
                            id,
                            HistoryType::Ok,
                            op,
                            None,
                        );
                    }
                    Err(err) => {
                        self.global.history.lock().unwrap().push_result(
                            &self.global,
                            id,
                            HistoryType::Fail,
                            op,
                            Some(err),
                        );
                    }
                }
            }
            OpOrNemesis::Nemesis(n) =>
            // TODO: use `get_or_init` when async clojure stablized
            {
                let n = match n {
                    AllNemesis::Execute(n) => n,
                    AllNemesis::Recover(_) => {
                        // TODO: remove recover type in AllNemesis
                        panic!("generated nemesis should not be a recover operation")
                    }
                };
                loop {
                    if self.all_handles.get().is_some() {
                        let calced = self.calculate_nemesis(n).await;
                        let (exec, recov) = self.n_register.lock().unwrap().put(calced);
                        if let Some(recov) = recov {
                            if exec == recov {
                                break;
                            } else {
                                self.recover_rec(recov).await;
                                self.execute_rec(exec).await;
                            }
                        } else {
                            self.execute_rec(exec).await;
                        }
                        break;
                    } else {
                        self.all_handles
                            .set(self.cluster_client.get_all_nodes_handle().await)
                            // The Result cannot be directly unwrapped because `NodeHandle` is
                            // !Debug
                            .map_err(|_| "set all nodes handle failed")
                            .unwrap();
                    }
                }
            }
        }
    }

    // There will be only one thread to run start_test, so the `join_handles` lock
    // will be held only by one thread, which could be safely held across await
    // point.
    #[allow(clippy::await_holding_lock)]
    async fn run(
        &'static self,
        mut gen: impl GeneratorIter<Item = OpOrNemesis> + Send,
    ) -> Result<SerializableCheckResult, Self::ERR> {
        while let Some((op, id)) = gen.next_with_id().await {
            self.handle_op(id, op).await;
        }
        info!("all receiver threads exited, check result...");

        // let his = serde_json::to_string(&self.global.history.lock().unwrap().
        // deref()).unwrap(); std::fs::write("test.json", his);

        let check_result = ElleRwChecker::default()
            .check(&self.global.history.lock().unwrap(), CheckOption::default());
        check_result.map_err(|err| err.to_string())
    }
}

/// The [`NemesisCluster`] trait implementation for [`JepsenClient`], use the
/// all `NodeHandle`s.
#[async_trait::async_trait]
impl<EC: ElleRwClusterClient + NemesisClusterClient + Send + Sync + 'static> NemesisCluster
    for JepsenClient<EC>
{
    async fn kill(&self, servers: &[ServerId]) {
        let handle = madsim::runtime::Handle::current();
        for id in servers {
            handle.kill(id.to_string());
        }
    }
    async fn restart(&self, servers: &[ServerId]) {
        let handle = madsim::runtime::Handle::current();
        for id in servers {
            handle.restart(id.to_string());
        }
    }
    async fn pause(&self, servers: &[ServerId]) {
        let net = madsim::net::NetSim::current();
        let handles = self.all_handles.get().expect("handles not found");
        for id in servers {
            net.clog_node(handles[*id as usize].id());
        }
    }
    async fn resume(&self, servers: &[ServerId]) {
        let net = madsim::net::NetSim::current();
        let handles = self.all_handles.get().expect("handles not found");
        for id in servers {
            net.unclog_node(handles[*id as usize].id());
        }
    }
    async fn get_leader_without_term(&self) -> ServerId {
        self.cluster_client.get_leader_without_term().await
    }
    fn clog_link_both(&self, fst: ServerId, snd: ServerId) {
        debug_assert!(fst < self.size() as u64 && snd < self.size() as u64);
        let net = madsim::net::NetSim::current();
        let handles = self.all_handles.get().expect("handles not found");
        let (i1, i2) = (handles[fst as usize].id(), handles[snd as usize].id());
        net.clog_link(i1, i2);
        net.clog_link(i2, i1);
    }
    fn unclog_link_both(&self, fst: ServerId, snd: ServerId) {
        debug_assert!(fst < self.size() as u64 && snd < self.size() as u64);
        let net = madsim::net::NetSim::current();
        let handles = self.all_handles.get().expect("handles not found");
        let (i1, i2) = (handles[fst as usize].id(), handles[snd as usize].id());
        net.unclog_link(i1, i2);
        net.unclog_link(i2, i1);
    }
    fn clog_link_single(&self, fst: ServerId, snd: ServerId) {
        debug_assert!(fst < self.size() as u64 && snd < self.size() as u64);
        let net = madsim::net::NetSim::current();
        let handles = self.all_handles.get().expect("handles not found");
        net.clog_link(handles[fst as usize].id(), handles[snd as usize].id());
    }
    fn unclog_link_single(&self, fst: ServerId, snd: ServerId) {
        debug_assert!(fst < self.size() as u64 && snd < self.size() as u64);
        let net = madsim::net::NetSim::current();
        let handles = self.all_handles.get().expect("handles not found");
        net.unclog_link(handles[fst as usize].id(), handles[snd as usize].id());
    }
    fn size(&self) -> usize {
        self.cluster_client.size()
    }
}
